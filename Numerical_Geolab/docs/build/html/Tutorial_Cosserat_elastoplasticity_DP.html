
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>4. Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic material &#8212; Numerical Geolab .1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Application of Thermo- Hydro- Mechanical (THM) couplings in Numerical Geolab" href="Tutorial_Cauchy_THM_couplings.html" />
    <link rel="prev" title="3. Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic material" href="Tutorial_Cosserat_elastoplasticity_VM.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Tutorial_Cauchy_THM_couplings.html" title="5. Application of Thermo- Hydro- Mechanical (THM) couplings in Numerical Geolab"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Tutorial_Cosserat_elastoplasticity_VM.html" title="3. Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic material"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Numerical Geolab .1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic  material</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="simple-shear-of-a-1d-cosserat-layer-with-drucker-prager-elastoplastic-material">
<h1><span class="section-number">4. </span>Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic  material<a class="headerlink" href="#simple-shear-of-a-1d-cosserat-layer-with-drucker-prager-elastoplastic-material" title="Permalink to this heading">¶</a></h1>
<p>In this tutorial we will study a 1D Cosserat elastic perfectly plastic layer under simple shear.
We provide the basic structure of a script file in the framework of Numerical Geolab.
Here we will study model formulation and analysis execution.</p>
<p>The file for this tutorial can be found in:
<a class="reference internal" href="ngeoFE_unittests.Mechanics.Cosserat.OneD.BVP.html#module-ngeoFE_unittests.Mechanics.Cosserat.OneD.BVP.Cosserat1D_Drucker_Prager_App_1" title="ngeoFE_unittests.Mechanics.Cosserat.OneD.BVP.Cosserat1D_Drucker_Prager_App_1"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ngeoFE_unittests.Mechanics.Cosserat.OneD.BVP.Cosserat1D_Drucker_Prager_App_1</span></code></a></p>
<section id="begining-of-file">
<h2><span class="section-number">4.1. </span>Begining of file<a class="headerlink" href="#begining-of-file" title="Permalink to this heading">¶</a></h2>
<p>Before we start giving the necessary commands for the formulation of the model specific python modules need to be loaded.
Below we provide a list of the modules needed and a brief explanation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="hll">  <span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</span>  <span class="kn">import</span> <span class="nn">time</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.feproblem</span> <span class="kn">import</span> <span class="n">UserFEproblem</span><span class="p">,</span> <span class="n">General_FEproblem_properties</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.fedefinitions</span> <span class="kn">import</span> <span class="n">FEformulation</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.materials</span> <span class="kn">import</span> <span class="n">UserMaterial</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE_unittests</span> <span class="kn">import</span> <span class="n">ngeo_parameters</span>
</span>  <span class="kn">from</span> <span class="nn">ngeoFE_unittests</span> <span class="kn">import</span> <span class="n">plotting_params</span>

  <span class="kn">import</span> <span class="nn">os</span> <span class="c1">#allows easier manipulation of directories</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">The dolfin package needs to be loaded since the classes used by Numerical Geolab inherit from the basic classes of the dolfin package, which is part of the FeniCs software. (Important)</div>
<div class="line">We import the time module for monitoring time during the analysis.</div>
<div class="line">We import numpy in order to manipulate the analysis results and insert the material parameters.</div>
<div class="line">We continue by importing the Numerical Geolab modules that wrap around FeniCs functionality:(Important)</div>
</div>
<ul class="simple">
<li><p>from ngeoFE.feproblem we import the classes of UserFeproblem() and General_FEproblem_properties() that will transform our series of commands to a problem understood by dolfin</p></li>
<li><p>from ngeoFE.fedefinitions we import the class of FEformulation() that defines the vector of unknown derivatives to be used in the variational form solved by the dolfin package.</p></li>
<li><p>from ngeoFE.materials we import the UserMaterial() class where the material is specified.</p></li>
<li><p>from ngeoFE_unittests we import ngeo_parameters. This file contains the material library path and reference data that can be used to check the analysis results in the context of a unittest.</p></li>
</ul>
<div class="line-block">
<div class="line">We import os to allow for easier manipulation of directories.</div>
</div>
</section>
<section id="finite-element-formulation">
<h2><span class="section-number">4.2. </span>Finite Element Formulation<a class="headerlink" href="#finite-element-formulation" title="Permalink to this heading">¶</a></h2>
<div class="line-block">
<div class="line">In order to continue we need to provide the form of the test function to be used together with the interpolation function (solution) to be used in the specific problem’s weak formulation.</div>
</div>
<p>We do this by specifying the number of vector components for the test function, the interpolation function used inside the element and the number Gauss points present in the element for the integral evaluation
of the weak form.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cosserat1DFEformulation</span><span class="p">(</span><span class="n">FEformulation</span><span class="p">):</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Defines a user FE formulation</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Number of stress/deformation components</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p_nstr</span><span class="o">=</span><span class="mi">4</span>
    <span class="c1"># Number of Gauss points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">generalized_epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set user&#39;s generalized deformation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scale_u</span><span class="o">=</span><span class="mf">1.</span><span class="c1">#1./1000.</span>
    <span class="n">gde</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">scale_u</span><span class="p">,</span>              <span class="c1">#gamma_11</span>
        <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">scale_u</span><span class="p">,</span>                    <span class="c1">#gamma_12</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">scale_u</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">scale_u</span><span class="p">,</span> <span class="c1">#gamma_21</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">scale_u</span><span class="p">,</span>              <span class="c1">#kappa_31</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">as_vector</span><span class="p">(</span><span class="n">gde</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">create_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set desired element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">element1</span><span class="o">=</span><span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">element2</span><span class="o">=</span><span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>

    <span class="n">element</span><span class="o">=</span><span class="n">MixedElement</span><span class="p">([</span><span class="n">element1</span><span class="p">,</span><span class="n">element2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">element</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">We note here that our problem is a 1D problem involving a micromorphic Cosserat continuum. Thus only 4 of the 18 strain and curvature components <img class="math" src="_images/math/340f7f47a5437962712abe66e8820705987ba726.png" alt="(\gamma_{11},\gamma_{12},\gamma_{21},\kappa_{31})"/> used for the equilibrium equations are needed.
We note also that we provide the generalized Voigt notation for the unknown strains of the problem.</div>
</div>
<p>In the code snippet above, we provide the finite element formulation for the problem at hand. This is a Mixed finite element that consist of a the displacement and the rotation field. We consider first order polynomials for the shape functions of the
displacement field and the rotation field. The class is initialized with 4 strain and curvature components and 1 Gauss point. The python function:</p>
<dl class="py method">
<dt class="sig sig-object py" id="generalized_epsilon">
<span class="sig-name descname"><span class="pre">generalized_epsilon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#generalized_epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="line-block">
<div class="line">presents the derivatives of the vector components of the Testfunction according to the Voigt formulation.</div>
</div>
<p>The notation used by the dolfin package indicates that Dx(v[i],j) is the derivative of the vector component (i) of the
Testfunction (v), w.r.t. the spatial direction (j). The Testfunction is an object of the dolfin package available in the
FeniCs documentation.</p>
<p><a href="#id1"><span class="problematic" id="id2">|</span></a>The python function:</p>
<dl class="py method">
<dt class="sig sig-object py" id="create_element">
<span class="sig-name descname"><span class="pre">create_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#create_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="line-block">
<div class="line">sets the desired element from the dolfin library of finite elements. Here a two dimensional (dim=2) linear (degree=1) VectorElement() is used. The VectorElement() class is documented in the dolfin finite element package of FeniCs.</div>
</div>
<p>We note here that the VectorElelement() class indicates that the components of the function space for each vector component are the same.</p>
</section>
<section id="finite-element-problem-description">
<h2><span class="section-number">4.3. </span>Finite element problem description<a class="headerlink" href="#finite-element-problem-description" title="Permalink to this heading">¶</a></h2>
<p>We proceed now with building the main Finite element model, corresponding to shearing in 2D of a Cauchy elastoplastic layer with a Von Mises yield criterion and strain hardening.
The finite element model is built inside a child class that inherits its methods from the parentclass UserFEproblem(). We will provide here commentary for each method used inside the childclass Cauchy2DFEproblem(UserFEproblem).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cosserat1DFEproblem</span><span class="p">(</span><span class="n">UserFEproblem</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines a user FE problem for given FE formulation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">FEformulation</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Example of 1D problem, Cosserat continuum with Drucker Prager material&quot;</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span><span class="o">=</span><span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Pressure_loading</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="mf">200.</span><span class="o">/</span><span class="mf">3.</span><span class="o">*</span><span class="n">scale</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span> <span class="o">=</span> <span class="o">-</span><span class="mf">600.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">scale</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Pressure_loading</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_total</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Pressure_loading</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">FEformulation</span><span class="p">)</span>
</pre></div>
</div>
<p>In the class __init__() method, the finite element formulation defined above is provided as argument. Because a Drucker - Prager yield criterion is used,
an initial effective confining stress needs to be applied to the model. In the initialization step we set the values of the variables storing the effective and total
confining stress at the beginning of the analysis. We will initialize the appropriate stress components of the model later in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_initial_conditions()</span></code> method below.
The initialization then proceeds to set up all the methods of the parentclass UserFEproblem(). The methods inside the class are
defined by overriding the methods inside the parent class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_general_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set here all the parameters of the problem, except material properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">genprops</span><span class="o">=</span><span class="n">General_FEproblem_properties</span><span class="p">()</span>
    <span class="c1"># Number of state variables</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">genprops</span><span class="o">.</span><span class="n">p_nsvars</span><span class="o">=</span><span class="mi">85</span>
</pre></div>
</div>
<p>This method is used to provide the number of state variables of the material. In this tutorial only the mechanical behavior is important
and therefore, the state of material is described by the increment of stress, generalized stress, total strain, total curvature, elastic strain, elastic curvature, plastic strain, plastic curvature,
plastic strain multiplier and plastic strain/curvature rate. Notice that even though the problem is in 1D and 18 strain/curvature components (and consequently  18 stress/ generalized stress components)
are needed for the description of equilibrium. The state of the material contains the information also for the rest components of the general 3D problem. For each material used by the Numerical Geolab,
the number of state variable components is given in <a class="reference internal" href="material_description_state_variables.html#material-description-of-state-variables"><span class="std std-ref">material properties table</span></a>.</p>
<div class="line-block">
<div class="line">Next we continue by generating the mesh for the problem at hand. Here, a 1D Cosserat layer is modeled as a bounded interval of length 1.</div>
</div>
<p>For this simple geometry the capabilities of dolfin can be used to define a rectangular mesh specifying the left and right points of the interval domain.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set mesh and subdomains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">=</span><span class="mf">1.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">=</span><span class="n">IntervalMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="p">,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">cd</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">fd</span>
</pre></div>
</div>
<p>For the domain at hand we specify a discretization with nx=1 element along the x[0] component. The MeshFunction() method of dolfin is used to
provide the mesh object, the interior domain and the boundary domains.</p>
<p>We next assign values to the regions of the mesh defined by different material properties.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_subdomains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create subdomains by marking regions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
    <span class="n">subdomains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#assigns material/props number 0 everywhere</span>
    <span class="k">return</span> <span class="n">subdomains</span>
</pre></div>
</div>
<p>In this tutorial all the domain is defined by the same material properties and therefore the value 0 will be assigned everywhere inside the mesh.
This value is a number indicating which material parameters need to be taken into account in each mesh region (see the corresponding method <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_material_params()</span></code>).</p>
<p>Next, we define the boundary selection class of the model. We perform the definition of the boundary inside the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Cosserat1DFEproblem</span></code> class. In particular we define the <code class="xref py py-class docutils literal notranslate"><span class="pre">Boundary</span></code> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Boundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">xyz</span><span class="p">,</span><span class="n">param</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="o">=</span><span class="n">param</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">DOLFIN_EPS</span>
        <span class="k">return</span> <span class="n">on_boundary</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">param</span><span class="p">)</span>
</pre></div>
</div>
<p>This class inherits from the <code class="xref py py-class docutils literal notranslate"><span class="pre">SubDomain</span></code> of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">dolfin</span></code> module. We redefine the <code class="xref py py-meth docutils literal notranslate"><span class="pre">inside()</span></code> method so that it
finds the points of the domain whose coordinate is close to the value set by the <code class="xref py py-const docutils literal notranslate"><span class="pre">param</span></code> variable.</p>
<p>We use the same definition to define the Gauss points selection class that we will inquire for results after the end of the
analysis. We restrict the region of interest to 1 element. Therefore, one Gauss point will be considered</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Gauss_point_Querry</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">nw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">=</span><span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="o">=</span><span class="n">nw</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="p">)))</span>
</pre></div>
</div>
<p>Finally, we use the methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">Meshfunction()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">mark()</span></code> in order to return the Gauss point that is of interest.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_Gauss_point_querry_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create subdomains by marking regions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GaussDomain</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
    <span class="n">GaussDomain</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#assigns material/props number 0 everywhere</span>
    <span class="n">GaussDomainQuerry</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gauss_point_Querry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nw</span><span class="p">)</span>
    <span class="n">GaussDomainQuerry</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">GaussDomain</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GaussDomain</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">Using the same logic, we continue by marking the boundaries of the model based on the <code class="xref py py-class docutils literal notranslate"><span class="pre">Boundary</span></code> class we defined earlier.</div>
</div>
<p>We do so by assigning the numbers 1 to 2 to the left and right interval bounds of the model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mark_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark left and right boundary points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Boundary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">left0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">right0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Boundary</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">right0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">return</span>
</pre></div>
</div>
<section id="definition-of-initial-conditions">
<h3><span class="section-number">4.3.1. </span>Definition of initial conditions<a class="headerlink" href="#definition-of-initial-conditions" title="Permalink to this heading">¶</a></h3>
<p>We proceed now to define the initial conditions of the problem. Here we set the initial confinement stress at the
normal stress components of the material. Moreover we initialize the total stress field <img class="math" src="_images/math/68efdd4bb5a8dcd8f4e06ffef83b8711d7635a37.png" alt="\tau_{11}"/> used in equilibrium equations to the total stress value
Here because we consider a dry material the effective normal stress and the total normal stresses are equal. Finally we don’t set any initial displacement to the model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_initial_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize state variables vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Modify the state variables (corresponding to the stresses)</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">genprops</span><span class="o">.</span><span class="n">p_nsvars</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">5</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">9</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">svars2</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>

    <span class="c1">#Modify the stresses (for Paraview)</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_total</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">sigma2</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>
    <span class="n">tmp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">usol</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>

    <span class="k">pass</span>
</pre></div>
</div>
</section>
<section id="assigning-boundary-conditions">
<h3><span class="section-number">4.3.2. </span>Assigning boundary conditions<a class="headerlink" href="#assigning-boundary-conditions" title="Permalink to this heading">¶</a></h3>
<p>We are now able to identify the boundaries of the mesh and assign different boundary condition to each side of the boundary.
The way we apply the boundary conditions can be seen in the method:</p>
<dl class="py method">
<dt class="sig sig-object py" id="set_bcs">
<span class="sig-name descname"><span class="pre">set_bcs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#set_bcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_bcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set boundary conditions for the user problem / could be replaced by external mesher, e.g. Abaqus, Gmsh...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Normal_loading_eff</span>
    <span class="n">tanfi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Gc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">u1_tot</span><span class="o">=</span><span class="n">p</span><span class="o">*</span><span class="n">tanfi</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">h1</span><span class="o">+</span><span class="n">h2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">G</span><span class="o">-</span><span class="n">Gc</span><span class="p">))</span>

    <span class="n">scale_u</span><span class="o">=</span><span class="mf">1.</span>

    <span class="n">bcs</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>

            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">]</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">u1_tot</span><span class="o">/</span><span class="n">scale_u</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">]</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span>

            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">u1_tot</span><span class="o">/</span><span class="n">scale_u</span><span class="p">]],</span>
            <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.</span><span class="p">]],</span>
            <span class="p">]</span>
    <span class="k">return</span> <span class="n">bcs</span>
</pre></div>
</div>
<p>Inside this method the boundaries are assigned with the use of a nested list. Dirichlet, Neuman and Robin boundary conditions can be applied
both incrementally and instantaneously. The boundary conditions can be assigned to a boundary region or pointwise.</p>
<div class="line-block">
<div class="line">The nested list contains the following information:</div>
</div>
<div class="line-block">
<div class="line">[region id, [type of bc, vector component ,value]]</div>
</div>
<p>In this example different boundary conditions are applied during the duration (steps) of the analysis. Initially the model is kept in place while the initial stress field is applied.
Then, at the later stages of the analysis, shearing takes place keeping the normal displacements fixed under zero generalized moments.</p>
<p>The region id ranges from 1 to 2 indicating the left, and right region of the boundary. Considering the displacement field, the type of bc is set to 0,
specifying incremental Dirichlet boundary conditions.The displacement vector components are defined based on the form of
the mixed finite element i.e [[displacement components], [rotation components]]. That is the displacement field is a list [x,y] that has two components, which need to be defined separately from the rotational field.
Because the displacement field precedes the rotation field in the definition of the Mixed finite element, its degrees of freedom start with 0 (x=0 in the list).
The second position in the list (variable y) indicates the normal (y=0) and shear component (y=1) of the displacement field respectively.</p>
<p>The rotational field has only one vector component and therefore it is denoted by the list [x], where x=1. We consider that during shearing the ends of the model are left free to rotate so that
the component of the generalized moment vector is zero. We inidicate this by setting the type of the boundary condition to 1 (Neumann boundary condition) and its value to zero.
In this case the Cosserat continuum behaves like a Cauchy until yielding.</p>
<p>We note further that the displacement values we set incrementally to the model are chosen such that the yielding of the model -start of plasticity- takes place at the start of the increment
(no intermediate value between two increments). The value of the incremental increase in shear displacement is then a function of the confinement
pressure and the material properties of the medium.</p>
</section>
<section id="assigning-the-nodal-history-output">
<h3><span class="section-number">4.3.3. </span>Assigning the nodal history output<a class="headerlink" href="#assigning-the-nodal-history-output" title="Permalink to this heading">¶</a></h3>
<p>Numerical Geolab offers the user the capability of extracting the output at the nodes and regions of the boundary at the converged increments
of the numerical analysis. This capability is given to the user in order to obtain the specific nodal output of the solution (forces, displacements)
instead of using the interpolated results provided in a separate .vtk file for postprocessing with a third party software
(e.g. Paraview). The history output at the nodes can be given by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">history_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to get output of residual at selected node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hist</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>

          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">]</span>
    <span class="k">return</span> <span class="n">hist</span>
</pre></div>
</div>
<p>We note that the same principle as in the case of the boundary conditions definitions apply.</p>
<p>In this application we also take note of the state variables of the problem in particular at the Gauss point we have isolated,
we inquire about the stresses, moments, strains, curvatures and plastic multiplier. We will use these quantities later for validating
the response of the Cosserat model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">history_svars_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to get output of svars at selected Gauss point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hist_svars</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">]]],</span> <span class="c1">#tau_11</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span> <span class="c1">#tau_12</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">2</span><span class="p">]]],</span> <span class="c1">#tau_13</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">3</span><span class="p">]]],</span> <span class="c1">#tau_21</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">4</span><span class="p">]]],</span> <span class="c1">#tau_22</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">5</span><span class="p">]]],</span> <span class="c1">#tau_23</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">6</span><span class="p">]]],</span> <span class="c1">#tau_31</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">7</span><span class="p">]]],</span> <span class="c1">#tau_32</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">8</span><span class="p">]]],</span> <span class="c1">#tau_33</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">9</span><span class="p">]]],</span> <span class="c1">#mu_11</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">10</span><span class="p">]]],</span> <span class="c1">#mu_12</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">11</span><span class="p">]]],</span> <span class="c1">#mu_13</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">12</span><span class="p">]]],</span> <span class="c1">#mu_21</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">13</span><span class="p">]]],</span> <span class="c1">#mu_22</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">14</span><span class="p">]]],</span> <span class="c1">#mu_23</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">15</span><span class="p">]]],</span> <span class="c1">#mu_31</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">16</span><span class="p">]]],</span> <span class="c1">#mu_32</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">17</span><span class="p">]]],</span> <span class="c1">#mu_33</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">18</span><span class="p">]]],</span> <span class="c1">#gamma_11</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">19</span><span class="p">]]],</span> <span class="c1">#gamma_12</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">20</span><span class="p">]]],</span> <span class="c1">#gamma_13</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">21</span><span class="p">]]],</span> <span class="c1">#gamma_21</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">22</span><span class="p">]]],</span> <span class="c1">#gamma_22</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">23</span><span class="p">]]],</span> <span class="c1">#gamma_23</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">24</span><span class="p">]]],</span> <span class="c1">#gamma_31</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">25</span><span class="p">]]],</span> <span class="c1">#gamma_32</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">26</span><span class="p">]]],</span> <span class="c1">#gamma_33</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">27</span><span class="p">]]],</span> <span class="c1">#kappa_11</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">28</span><span class="p">]]],</span> <span class="c1">#kappa_12</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">29</span><span class="p">]]],</span> <span class="c1">#kappa_13</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">30</span><span class="p">]]],</span> <span class="c1">#kappa_21</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">31</span><span class="p">]]],</span> <span class="c1">#kappa_22</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">32</span><span class="p">]]],</span> <span class="c1">#kappa_23</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">33</span><span class="p">]]],</span> <span class="c1">#kappa_31</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">34</span><span class="p">]]],</span> <span class="c1">#kappa_32</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">35</span><span class="p">]]],</span> <span class="c1">#kappa_33</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">57</span><span class="p">]]],</span> <span class="c1">#lambda_dot</span>
                <span class="p">]</span>
    <span class="k">return</span> <span class="n">hist_svars</span>
</pre></div>
</div>
</section>
</section>
<section id="material-specification">
<h2><span class="section-number">4.4. </span>Material specification<a class="headerlink" href="#material-specification" title="Permalink to this heading">¶</a></h2>
<p>Next, we define the analysis material that we have already assigned in the create_subdomains() method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create material objects and set material parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mats</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># load material #1</span>

    <span class="n">env_lib</span><span class="o">=</span><span class="n">ngeo_parameters</span><span class="o">.</span><span class="n">env_lib</span>
    <span class="n">umat_lib_path</span><span class="o">=</span> <span class="n">ngeo_parameters</span><span class="o">.</span><span class="n">umat_lib_path</span>
    <span class="n">umat_lib</span> <span class="o">=</span> <span class="n">umat_lib_path</span><span class="o">+</span><span class="s1">&#39;/COSSERAT3D/libplast_Cosserat3D.so&#39;</span>
    <span class="n">umat_id</span><span class="o">=</span><span class="mi">1</span>      <span class="c1"># if many materials exist in the same library</span>
    <span class="n">mat</span><span class="o">=</span><span class="n">UserMaterial</span><span class="p">(</span><span class="n">env_lib</span><span class="p">,</span><span class="n">umat_lib</span><span class="p">,</span><span class="n">umat_id</span><span class="p">)</span>
    <span class="n">mat</span><span class="o">.</span><span class="n">props</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_material_1_properties</span><span class="p">()</span>
    <span class="c1">#</span>
    <span class="n">mats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mats</span>
</pre></div>
</div>
<p>The ngeo_parameters.py module contains the relative path to the materials libraries, which specify the different materials available to the user.
The variable umat_id=1 needs to be set for the 1D analyses performed here. It specifies the mapping of the updated vector components of the strain increment <img class="math" src="_images/math/340f7f47a5437962712abe66e8820705987ba726.png" alt="(\gamma_{11},\gamma_{12},\gamma_{21},\kappa_{31})"/>
and corresponding tensor components of the constitutive matrix, with their position in the 3D strain/curvature vector and constitutive matrix provided at the material subroutine (material algorithm).
This mapping returns back the correct components of the stress vector and constitutive matrix to pass into the residual calculation of the weak form in dolfin (equilibrium iterations). The material properties passed into the material algorithm, are set with the helper method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_material_1_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets material parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">g1</span><span class="o">=</span><span class="mf">8.</span><span class="o">/</span><span class="mf">5.</span><span class="p">;</span><span class="n">g2</span><span class="o">=</span><span class="mf">2.</span><span class="o">/</span><span class="mf">5.</span><span class="p">;</span><span class="n">g3</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span><span class="n">g4</span><span class="o">=</span><span class="mf">0.</span>

    <span class="n">h1</span><span class="o">=</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span> <span class="p">;</span><span class="n">h2</span><span class="o">=-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">6.</span><span class="p">;</span><span class="n">h3</span><span class="o">=</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">;</span><span class="n">h4</span><span class="o">=-</span><span class="mf">1.</span><span class="o">/</span><span class="mf">6.</span><span class="p">;</span>

    <span class="n">K</span><span class="o">=</span><span class="mf">666.66</span><span class="p">;</span> <span class="n">G</span><span class="o">=</span><span class="mf">1.</span><span class="o">*</span><span class="mf">10.</span><span class="o">**</span><span class="mf">3.</span><span class="p">;</span> <span class="n">Gc</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="mf">10.</span><span class="o">**</span><span class="mf">3.</span> <span class="p">;</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">2.</span><span class="p">);</span><span class="n">R</span><span class="o">=</span><span class="mf">10.</span><span class="o">*</span><span class="mf">10.</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="p">);</span>
    <span class="n">MG</span><span class="o">=</span><span class="n">G</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span><span class="o">/</span><span class="n">h3</span> <span class="p">;</span> <span class="n">MGc</span><span class="o">=</span><span class="n">MG</span><span class="p">;</span>
    <span class="n">tanfi</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span> <span class="n">cc</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span>
    <span class="n">tanpsi</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">Hsfi</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">Hscc</span><span class="o">=-</span><span class="mf">0.</span><span class="p">;</span>
    <span class="n">eta1</span><span class="o">=</span><span class="mf">0.0</span>

    <span class="n">prop_num</span><span class="o">=</span><span class="mi">29</span>
    <span class="n">props</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">prop_num</span><span class="p">)</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">K</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">G</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">Gc</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="n">L</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">MG</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">MGc</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="n">R</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="n">tanfi</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">=</span><span class="n">cc</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">=</span><span class="n">tanpsi</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">=</span><span class="n">Hsfi</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">=</span><span class="n">Hscc</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">=</span><span class="n">h1</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="o">=</span><span class="n">h2</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="o">=</span><span class="n">h3</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">=</span><span class="n">h4</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">=</span><span class="n">g1</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">=</span><span class="n">g2</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="o">=</span><span class="n">g3</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">22</span><span class="p">]</span><span class="o">=</span><span class="n">g4</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span><span class="o">=</span><span class="n">eta1</span>

    <span class="k">return</span> <span class="n">props</span>
</pre></div>
</div>
<p>In this example we chose to provide the material young modulus EE, Poisson ratio nu, the material yield strength in simple shear cc and the isotropic hardening parameter during yield equal to H=1.
The parameters passed into the material subroutine are the 3D isotropic compression modulus KK and the shear modulus GG.
Therefore, a transformation of the elastic constants is needed. The elastic constants (GG, KK) used together with the material hardening parameter, H,
and their position in the material properties (numpy array props), can be found in Table (reference needed) and the material library files that accompany Numerical Geolab.</p>
<div class="line-block">
<div class="line">Once the analysis material(s) have been set we are able to exit the class definition for Cosserat1DFEproblem(UserFEproblem).</div>
</div>
</section>
<section id="analysis-execution">
<h2><span class="section-number">4.5. </span>Analysis execution<a class="headerlink" href="#analysis-execution" title="Permalink to this heading">¶</a></h2>
<p>Our model is now set and ready to run. In order to perform an analysis for the problem at hand, we can simply type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_FEformulation</span><span class="o">=</span><span class="n">Cosserat1DFEformulation</span><span class="p">()</span>
<span class="n">my_FEproblem</span><span class="o">=</span><span class="n">Cosserat1DFEproblem</span><span class="p">(</span><span class="n">my_FEformulation</span><span class="p">)</span>
<span class="n">path1</span><span class="o">=</span><span class="s1">&#39;../reference_data&#39;</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;Cosserat1D_Drucker_Prager_tests_App_1&#39;</span>
<span class="n">saveto</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.xdmf&#39;</span><span class="p">)</span>
<span class="n">converged</span><span class="o">=</span><span class="n">my_FEproblem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span><span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This will use the solve method inside the parent UserFeproblem() class that starts the solution procedure. The analysis results are the saved to an ‘.xdmf’ file to be
postprocessed by a third party application (e.g. Paraview).</p>
</section>
<section id="control-of-the-solution-procedure">
<h2><span class="section-number">4.6. </span>Control of the solution procedure<a class="headerlink" href="#control-of-the-solution-procedure" title="Permalink to this heading">¶</a></h2>
<p>The FEproblem() class of Numerical Geolab allows for great flexibility in choosing the solver parameters with which an analysis can be performed.
Below a set of parameters can be passed as attributes to the solver for controlling the frequency of writing output (my_FEproblem.slv.incmodulo),
the tolerance (my_FEproblem.slv.convergence_tol), the maximum increment size (my_FEproblem.slv.dtmax), the maximum analysis time
(my_FEproblem.slv.tmax) and the maximum number of increments (my_FEproblem.slv.nincmax=50). We intorduce these parameters of the solution procedure
in the <code class="xref py py-meth docutils literal notranslate"><span class="pre">give_me_solver_params()</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">give_me_solver_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">scale_t</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span> <span class="o">=</span> <span class="n">scale_t</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">incmodulo</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">tmax</span><span class="o">=</span><span class="mf">1.</span><span class="o">*</span><span class="n">scale_t</span>
    <span class="n">ninc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">tmax</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dtmax</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">nincmax</span><span class="o">=</span><span class="mi">50</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">convergence_tol</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">6</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">removezerolines</span><span class="o">=</span><span class="kc">False</span>
</pre></div>
</div>
<p>After we have defined the analysis parameters we specify the analysis steps. The analysis is separated into seven steps. Th first step is the initial step, where the model
is held still until the application of the initial confining stress. After the  initial prestress the model is sheared. The first step of shear is elastic and finishes when t
the elastic limit of the structure is reached. After the termination of each step, the solver applies the boundary conditions of the next step to the model using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">initBCs()</span></code> method
and solves the problem using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_analysis_procedure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">reference_data_path</span><span class="p">):</span>
    <span class="n">saveto</span><span class="o">=</span><span class="n">reference_data_path</span><span class="o">+</span><span class="s2">&quot;Cosserat_1D_Drucker-Prager_test_step_0&quot;</span><span class="o">+</span><span class="s2">&quot;_App_1&quot;</span><span class="o">+</span><span class="s2">&quot;.xdmf&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_bcs</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">symbolic_bcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;initial&quot;</span><span class="p">)</span>
    <span class="n">converged</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span><span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">scale_t_program</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_t</span><span class="p">]</span>
    <span class="n">ninc</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shearing1&quot;</span><span class="p">)</span>

    <span class="n">nsteps</span><span class="o">=</span><span class="mi">6</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsteps</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">scale_t</span> <span class="o">=</span> <span class="n">scale_t_program</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">nincmax</span><span class="o">=</span><span class="n">ninc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">scale_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dtmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">tmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">tmax</span><span class="o">+</span><span class="mf">1.</span><span class="o">*</span><span class="n">scale_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">symbolic_bcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_bcs</span><span class="p">(),</span> <span class="n">key</span> <span class="o">=</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">initBCs</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;Cosserat_1D_Drucker-Prager_test_step_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">saveto</span><span class="o">=</span> <span class="n">reference_data_path</span><span class="o">+</span><span class="s2">&quot;Cosserat_1D_Drucker-Prager_test_step_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_App_1&quot;</span><span class="o">+</span><span class="s2">&quot;.xdmf&quot;</span>
        <span class="n">converged</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span><span class="n">summary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">converged</span>
</pre></div>
</div>
</section>
<section id="analysis-results">
<h2><span class="section-number">4.7. </span>Analysis results<a class="headerlink" href="#analysis-results" title="Permalink to this heading">¶</a></h2>
<p>For this simple example we are able to evaluate analytically the analytical expression of the plastic strain multiplier. We evaluate the expression using the applied rate of shear displacement
to the model. In order to extract the shear displacement from the nodes we specified earlier in the analysis results, using the <a class="reference internal" href="Tutorial_Cauchy_elastoplasticity_VM.html#history_output" title="history_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">history_output()</span></code></a> we first note that the results of the <a class="reference internal" href="Tutorial_Cauchy_elastoplasticity_VM.html#history_output" title="history_output"><code class="xref py py-meth docutils literal notranslate"><span class="pre">history_output()</span></code></a>
are given as a nested list of the following structure:</p>
<div class="line-block">
<div class="line">[[0, [force at y in first node of region 2, force at y in second node of region 2 ], [displacement at y in first node of region 2, displacement at y in second node of region 2 ]],…,</div>
<div class="line">[maximum analysis time, [force at y in first node of region 2, force at y in second node of region 2 ], [displacement at y in first node of region 2, displacement at y in second node of region 2 ]]</div>
</div>
<div class="line-block">
<div class="line">In order to extract the results we define a function that unpacks the above nested list into timestamps, nodal displacements and nodal forces</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">history_unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">list1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list1</span><span class="p">):</span>
        <span class="c1"># print(elem)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_force</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_disp</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">array_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_time</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_force</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_force</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])))))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_disp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_disp</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">])))))</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">The same is true for the state variables.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">svars_history_unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">list1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># print(elem)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_dtime</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array_gp_svars_comp</span><span class="o">=</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">continue</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">array_dtime</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_dtime</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array_gp_svars_comp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">array_gp_svars_comp</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])))))</span>
</pre></div>
</div>
<p>We further define the extract functions that give the final form to the extracted matrices for the analysis result objects.
We can use the resulting object instances in analytical calculations for the verification of our numerical analyses.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_force_disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">analysis_history</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">problem_history</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">history_unpack</span><span class="p">(</span><span class="n">analysis_history</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_time</span><span class="p">[:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array_force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_force</span><span class="p">[:,:]</span><span class="c1">#.reshape((-1,20))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array_disp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_disp</span><span class="p">[:,:]</span><span class="c1">#.reshape((-1,20)).copy()</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">extract_svars_gauss_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">analysis_svars_history</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">problem_svars_history</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">svars_history_unpack</span><span class="p">(</span><span class="n">analysis_svars_history</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array_dtime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_dtime</span><span class="p">[:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">array_gp_svars_comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">array_gp_svars_comp</span><span class="p">[:,:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p>Using the above results we can extract the elasto-plastic model’s numerical response due to shear. Our model contains only one element therefore,
we expect its response to coincide with that of the elastoplastic material i.e. homogeneous deformation. The results of the analysis are summarized in the following figure.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><figure class="align-center" id="id3">
<a class="reference internal image-reference" href="_images/Cosserat_1D_Drucker-Prager_App_1_J2_q.svg"><img alt="alternate text" height="200px" src="_images/Cosserat_1D_Drucker-Prager_App_1_J2_q.svg" width="400px" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4.7.1 </span><span class="caption-text">Deviatoric stress vs deviatoric strain during the analysis.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-center" id="id4">
<a class="reference internal image-reference" href="_images/Cosserat_1D_Drucker-Prager_App_1_ldot_error_an_c_t.svg"><img alt="alternate text" height="200px" src="_images/Cosserat_1D_Drucker-Prager_App_1_ldot_error_an_c_t.svg" width="400px" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4.7.2 </span><span class="caption-text">Analytical vs numerical plastic coefficient. .</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><figure class="align-center" id="id5">
<a class="reference internal image-reference" href="_images/Cosserat_1D_Drucker-Prager_App_1_ldot_error_rel_t.svg"><img alt="alternate text" height="200px" src="_images/Cosserat_1D_Drucker-Prager_App_1_ldot_error_rel_t.svg" width="400px" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4.7.3 </span><span class="caption-text">Relative error between the analytical and numerically evaluated plastic coefficient.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">4. Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic  material</a><ul>
<li><a class="reference internal" href="#begining-of-file">4.1. Begining of file</a></li>
<li><a class="reference internal" href="#finite-element-formulation">4.2. Finite Element Formulation</a></li>
<li><a class="reference internal" href="#finite-element-problem-description">4.3. Finite element problem description</a><ul>
<li><a class="reference internal" href="#definition-of-initial-conditions">4.3.1. Definition of initial conditions</a></li>
<li><a class="reference internal" href="#assigning-boundary-conditions">4.3.2. Assigning boundary conditions</a></li>
<li><a class="reference internal" href="#assigning-the-nodal-history-output">4.3.3. Assigning the nodal history output</a></li>
</ul>
</li>
<li><a class="reference internal" href="#material-specification">4.4. Material specification</a></li>
<li><a class="reference internal" href="#analysis-execution">4.5. Analysis execution</a></li>
<li><a class="reference internal" href="#control-of-the-solution-procedure">4.6. Control of the solution procedure</a></li>
<li><a class="reference internal" href="#analysis-results">4.7. Analysis results</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Tutorial_Cosserat_elastoplasticity_VM.html"
                          title="previous chapter"><span class="section-number">3. </span>Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic  material</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="Tutorial_Cauchy_THM_couplings.html"
                          title="next chapter"><span class="section-number">5. </span>Application of Thermo- Hydro- Mechanical (THM) couplings in Numerical Geolab</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Tutorial_Cauchy_THM_couplings.html" title="5. Application of Thermo- Hydro- Mechanical (THM) couplings in Numerical Geolab"
             >next</a> |</li>
        <li class="right" >
          <a href="Tutorial_Cosserat_elastoplasticity_VM.html" title="3. Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic material"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Numerical Geolab .1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">4. </span>Simple shear of a 1D Cosserat layer with Drucker-Prager elastoplastic  material</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Ioannis Stefanou.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.0.
    </div>
  </body>
</html>