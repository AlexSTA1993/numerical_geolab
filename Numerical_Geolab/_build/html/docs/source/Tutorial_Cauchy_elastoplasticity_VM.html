
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>1. Simple shear of a 2D Cacuhy layer with Von-Mises elastoplastic strain hardening material &#8212; Numerical Geolab 1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simple-shear-of-a-2d-cacuhy-layer-with-von-mises-elastoplastic-strain-hardening-material">
<h1>1. Simple shear of a 2D Cacuhy layer with Von-Mises elastoplastic strain hardening material<a class="headerlink" href="#simple-shear-of-a-2d-cacuhy-layer-with-von-mises-elastoplastic-strain-hardening-material" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial we will study a 2D Cauchy layer elastop-plastic layer with strain hardening under simple shear.
In this tutorial we provide the basic structure of a script file in the framework of Numerical Geolab.
Here we will study model formulation and analysis execution.</p>
<p>The file for this tutorial can be found in: ./Numerical_Geolab/ngeoFE_unittests/Mechanics/Cauchy2D_Von_Mises_test.py</p>
<div class="section" id="begining-of-file">
<h2>1.1. Begining of file<a class="headerlink" href="#begining-of-file" title="Permalink to this headline">¶</a></h2>
<p>Before we start giving the necessary commands for the formulation of the model specific python modules need to be loaded.
Below we provide a list of the modules needed and a brief explanation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="hll">  <span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</span>  <span class="kn">import</span> <span class="nn">time</span>
  <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.feproblem</span> <span class="kn">import</span> <span class="n">UserFEproblem</span><span class="p">,</span> <span class="n">General_FEproblem_properties</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.fedefinitions</span> <span class="kn">import</span> <span class="n">FEformulation</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE.materials</span> <span class="kn">import</span> <span class="n">UserMaterial</span>
</span><span class="hll">  <span class="kn">from</span> <span class="nn">ngeoFE_unittests</span> <span class="kn">import</span> <span class="n">ngeo_parameters</span>
</span>  <span class="kn">from</span> <span class="nn">ngeoFE_unittests</span> <span class="kn">import</span> <span class="n">plotting_params</span>

  <span class="kn">import</span> <span class="nn">os</span> <span class="c1">#allows easier manipulation of directories</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">The dolfin package needs to be loaded since the classes used by Numerical Geolab inherit from the basic classes of the dolfin package, which is part of the FeniCs software. (Important)</div>
<div class="line">We import the time module for monitoring time during the analysis.</div>
<div class="line">We import numpy in order to manipulate the analysis results and insert the materioal parameters.</div>
<div class="line">We continue by importing the numerical geolab modules that wrap around FeniCs functionality:(Important)</div>
</div>
<ul class="simple">
<li>from ngeoFE.feproblem we import the classes of UserFeproblem() and General_FEproblem_properties() that will transform our series of commands to a problem understood by dolfin</li>
<li>from ngeoFE.fedefinitions we import the class of FEformulation() that defines the vector of unknown derivatives to be used in the variational form solved by the dolfin package.</li>
<li>from ngeoFE.materials we import the UserMaterial() class where the material is specified.</li>
<li>from ngeoFE_unittests we import ngeo_parameters. This file contains the material library path and reference data that can be used to check the analysis results in the context of a unittest.</li>
</ul>
<div class="line-block">
<div class="line">We import os to allow for easier manipulation of directories.</div>
</div>
</div>
<div class="section" id="finite-element-formulation">
<h2>1.2. Finite Element Formulation<a class="headerlink" href="#finite-element-formulation" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">In order to continue we need to provide the form of the test function to be used together with the interpolation function (solution) to be used in the specific problem’s weak formulation.</div>
</div>
<p>We do this by specifying the number of vector components for the test function, the interpolation function used inside the element and the number Gauss points present in the element for the integral evaluation
of the weak form.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cauchy2DFEformulation</span><span class="p">(</span><span class="n">FEformulation</span><span class="p">):</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Defines a user FE formulation</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Number of stress/deformation components</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">p_nstr</span><span class="o">=</span><span class="mi">3</span>
    <span class="c1"># Number of Gauss points</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="o">=</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">generalized_epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set user&#39;s generalized deformation vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gde</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">),</span>  <span class="c1">#gamma_11</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">),</span>  <span class="c1">#gamma_11</span>
        <span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">Dx</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>  <span class="c1">#gamma_12</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">as_vector</span><span class="p">(</span><span class="n">gde</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">create_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set desired element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Defines a Lagrangian FE of degree 1 for the displacements</span>
    <span class="n">element_disp</span><span class="o">=</span><span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;Lagrange&quot;</span><span class="p">,</span><span class="n">cell</span><span class="p">,</span><span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">element_disp</span>
</pre></div>
</div>
<div class="line-block">
<div class="line">We note here that our problem is a plain strain 2D problem involving a classical Cauchy continuum. Thus only 3 of the 6 strain components <span class="math notranslate nohighlight">\((\gamma_{11},\gamma_{22},\gamma_{12})\)</span> used for the equilibrium equations are needed.
We note also that we provide the Voight notation for the unknown strains of the problem, therefore, the engineering strain notation for the shear strain needs to be used <span class="math notranslate nohighlight">\((\gamma_{12}=2\epsilon_{12})\)</span>.</div>
</div>
<p>In code snippet above, we provide the finite element formulation for the problem at hand. The class is initialized with 3 strain components and 1 Gauss point. The python function:</p>
<dl class="method">
<dt id="generalized_epsilon">
<code class="descname">generalized_epsilon</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#generalized_epsilon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="line-block">
<div class="line">presents the derivatives of the vector components of the Testfunction according to the Voight formulation. The notation used by the dolfin package indicates that Dx(v[i],j) is the derivative of the vector component (i) of the Testfunction (v), w.r.t. the spatial direction (j). The Testfunction is an object of the dolfin package available in the FeniCs documentation. The python function:</div>
</div>
<dl class="method">
<dt id="create_element">
<code class="descname">create_element</code><span class="sig-paren">(</span><em>cell</em><span class="sig-paren">)</span><a class="headerlink" href="#create_element" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="line-block">
<div class="line">sets the desired element from the dolfin library of finite elements. Here a two dimensional (dim=2) linear (degree=1) VectorElement() is used. The VectorElement() class is documented in the dolfin finite element package of FeniCs.</div>
</div>
<p>We note here that the VectorElelement() class indicates that the components of the function space for each vector component are the same.</p>
</div>
<div class="section" id="boundary-identification">
<h2>1.3. Boundary identification<a class="headerlink" href="#boundary-identification" title="Permalink to this headline">¶</a></h2>
<p>We proceed now by identifying the boundaries needed for the application of the boundary conditions at a later stage of the modeling procedure.
We make use of the SubDomain() parent class inside dolfin:</p>
<dl class="class">
<dt id="SuDomain">
<em class="property">class </em><code class="descname">SuDomain</code><span class="sig-paren">(</span><em>x</em>, <em>on_boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#SuDomain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>We create four subclasses (children) of the class, each for each side of the rectangular domain, which inherit from it the spatial variable (x) and the boundary identification flag (on_boundary) and the method</p>
<dl class="method">
<dt id="inside">
<code class="descname">inside</code><span class="sig-paren">(</span><em>x</em>, <em>on_boundary</em><span class="sig-paren">)</span><a class="headerlink" href="#inside" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The subclasses are defined as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">left</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
 <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">on_boundary</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">class</span> <span class="nc">right</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">class</span> <span class="nc">top</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">class</span> <span class="nc">bottom</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>Inside each subclass we define the logical test for assigning the specific boundary node in one of the boundary regions, where the boundary conditions will be applied.
The value x[i] indicates the spatial coordinate <span class="math notranslate nohighlight">\(x_i\)</span> of the problem at hand.</p>
</div>
<div class="section" id="finite-element-problem-description">
<h2>1.4. Finite element problem description<a class="headerlink" href="#finite-element-problem-description" title="Permalink to this headline">¶</a></h2>
<p>We proceed now with building the main Finite element model, corresponding to shearing in 2D of a Cauchy elastoplastic layer with a Von Mises yield criterion and strain hardening.
The finite element model is built inside a child class that inherits its methods from the parentclass UserFEproblem(). We will provide here commentary for each method used inside the childclass Cauchy2DFEproblem(UserFEproblem).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cauchy2DFEproblem</span><span class="p">(</span><span class="n">UserFEproblem</span><span class="p">):</span>
 <span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Defines a user FE problem for given FE formulation</span>
<span class="sd"> &quot;&quot;&quot;</span>
 <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">FEformulation</span><span class="p">):</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Example of 2D plane strain problem, Cauchy continuum&quot;</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">problem_step</span><span class="o">=</span><span class="mi">0</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="mf">1.</span>
     <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="mf">0.2</span>
     <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">FEformulation</span><span class="p">)</span>
</pre></div>
</div>
<p>In the class __init__() method, the finite element formulation defined above is provided as argument.The geometric dimensions of the problem are also specified
Its height self.h=1. and its width self.w=0.2 . The initialization then proceeds to set up all the methods of the parentclass UserFEproblem(). The methods inside the class are
defined by overriding the methods inside the parent class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_general_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set here all the parameters of the problem, except material properties</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">genprops</span><span class="o">=</span><span class="n">General_FEproblem_properties</span><span class="p">()</span>
    <span class="c1"># Number of state variables</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">genprops</span><span class="o">.</span><span class="n">p_nsvars</span><span class="o">=</span><span class="mi">38</span>
</pre></div>
</div>
<p>This method is used to provide the number of state variables of the material. In this tutorial only the mechanical behavior is important
and therefore, the state of material is described by the increment of stress, total strain, elastic strain, plastic strain, plastic strain multiplier
and plastic strain rate. Notice that even though the problem is in 2D and three strain components (and consequently  three stress components) are needed for the description of equilibrium
the state of the material contains the information also for the rest components of the general 3D problem. For each material used by the Numerical Geolab, the number of state variable
components is given in Table (To be referenced).</p>
<div class="line-block">
<div class="line">Next we continue by generating the mesh for the problem at hand. Here, a 2D Cauchy layer is modeled as a rectangle of height 1 and width 0.2.</div>
</div>
<p>For this simple geometry the capabilities of dolfin can be used to define a rectangular mesh specifying the bottom left and upper right corners of the rectangular domain.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set mesh and subdomains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generate mesh</span>
    <span class="n">h</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span>
    <span class="n">w</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">w</span>
    <span class="n">nx</span><span class="o">=</span><span class="mi">80</span>
    <span class="n">ny</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="n">h</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span><span class="n">Point</span><span class="p">(</span><span class="n">h</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span><span class="n">w</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="c1">#other options include &quot;right&quot;. &quot;crossed&quot;</span>
    <span class="n">cd</span><span class="o">=</span><span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
    <span class="n">fd</span><span class="o">=</span><span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span><span class="n">cd</span><span class="p">,</span><span class="n">fd</span>
</pre></div>
</div>
<p>For the domain at hand we specify a discretization with nx=80 elements along the x[0] component and ny=1 element along the x[1] component. The MeshFunction() method of dolfin is used to
provide the mesh object, the interior domain and the boundary domains. The following model is the produced:</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="../../_images/Cauchy_simple_shear_solid.png"><img alt="alternate text" src="../../_images/Cauchy_simple_shear_solid.png" style="width: 400px; height: 200px;" /></a>
<p class="caption"><span class="caption-text">Image of the rectangular mesh produced by RectangleMesh(). The domain was exported with the help of the third party software Paravew.</span></p>
</div>
<p>We next assign values to the regions of the mesh defined by different material properties.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_subdomains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create subdomains by marking regions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subdomains</span> <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">topology</span><span class="p">()</span><span class="o">.</span><span class="n">dim</span><span class="p">())</span>
    <span class="n">subdomains</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#assigns material/props number 0 everywhere</span>
    <span class="k">return</span> <span class="n">subdomains</span>
</pre></div>
</div>
<p>In this tutorial all the domain is defined by the same material properties and therfore the value 0 will be assigned everywhere inside the mesh.
This value is a number indicating which material parameters need to be taken into account in each mesh region (see the corresponding method set_material_params()).</p>
<div class="line-block">
<div class="line">We continue by marking the boundaries of the model based on the classes defined during the boundary identification phase (see section <span class="xref std std-ref">Boundary identification</span> above).</div>
</div>
<p>We do so by assigning the numbers 1 to 4 to the different regions of the model. To do this we use the method mark() from the SubDomain() class of dolfin.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mark_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">boundaries</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark left and right boundary points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">boundaries</span><span class="o">.</span><span class="n">set_all</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">left0</span><span class="o">=</span><span class="n">left</span><span class="p">()</span>
    <span class="n">left0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">right0</span><span class="o">=</span><span class="n">right</span><span class="p">()</span>
    <span class="n">right0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">top0</span><span class="o">=</span><span class="n">top</span><span class="p">()</span>
    <span class="n">top0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">bottom0</span><span class="o">=</span><span class="n">bottom</span><span class="p">()</span>
    <span class="n">bottom0</span><span class="o">.</span><span class="n">mark</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="section" id="assigning-boundary-conditions">
<h3>1.4.1. Assigning boundary conditions<a class="headerlink" href="#assigning-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>We are now able to identify the boundaries of the mesh and assign different boundary condition to each side of the boundary.
The way we apply the boundary conditions can be seen in the method:</p>
<dl class="method">
<dt id="set_bcs">
<code class="descname">set_bcs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#set_bcs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_bcs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set boundary conditions for the user problem / could be replaced by external mesher, e.g. Abaqus, Gmsh...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bcs</span><span class="o">=</span><span class="p">[</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mf">0.1</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]]</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">bcs</span>
</pre></div>
</div>
<p>Inside this method the boundaries are assigned with the use of a nested list. Dirichlet, Neuman and Robin boundary conditions can be applied
both incrementaly and instantaneously. The boundary conditions can be assigned to a boundary region or pointwise.</p>
<div class="line-block">
<div class="line">The nested list contains the following information:</div>
</div>
<div class="line-block">
<div class="line">[region id, [type of bc, vector component ,value]]</div>
</div>
<p>In this example, the region id ranges from 1 to 4 indicating the left, right,top and bottom regions of the boundaries. The type of bc is set to 0,
specifying incremental Dirichlet boundary conditions. The vector component shows which component of the 2D displacement vector is to be affected and value
indicates the value of the boundary condition to be set at the specific boundary.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="assigning-the-nodal-history-output">
<h3>1.4.2. Assigning the nodal history output<a class="headerlink" href="#assigning-the-nodal-history-output" title="Permalink to this headline">¶</a></h3>
<p>Numerical Geolab offers the user the capability of extracting the output at the nodes and regions of the boundary at the converged increments
of the numerical analysis. This capability is given to the user in order to obtain the specific nodal output of the solution (forces, displacements)
instead of using the interpolated results provided in a separate .vtk file for postprocessing with a third party software
(e.g. Paraview). The history output at the nodes can be given by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">history_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to get output of residual at selected node</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hist</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,[</span><span class="mi">1</span><span class="p">]]],</span>
          <span class="p">]</span>
    <span class="k">return</span> <span class="n">hist</span>
</pre></div>
</div>
<p>The node specification works the same way as in set_bcs(). In this example we choose the right edge of the boundary (2) in order to monitor the
second component ([1]) of the force (1) and displacement (0) fields respectively.</p>
</div>
</div>
<div class="section" id="material-specification">
<h2>1.5. Material specification<a class="headerlink" href="#material-specification" title="Permalink to this headline">¶</a></h2>
<p>Next, we define the analysis material that we have already assigned in the create_subdomains() method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_materials</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create material objects and set material parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mats</span><span class="o">=</span><span class="p">[]</span>
    <span class="c1"># load material #1</span>

    <span class="n">env_lib</span><span class="o">=</span><span class="n">ngeo_parameters</span><span class="o">.</span><span class="n">env_lib</span>
    <span class="n">umat_lib_path</span><span class="o">=</span> <span class="n">ngeo_parameters</span><span class="o">.</span><span class="n">umat_lib_path</span>
    <span class="n">umat_lib</span> <span class="o">=</span> <span class="n">umat_lib_path</span><span class="o">+</span><span class="s1">&#39;/CAUCHY3D-DP/libplast_Cauchy3D-DP.so&#39;</span>
    <span class="n">umat_id</span><span class="o">=</span><span class="mi">2</span>       <span class="c1"># if many materials exist in the same library</span>
    <span class="n">mat</span><span class="o">=</span><span class="n">UserMaterial</span><span class="p">(</span><span class="n">env_lib</span><span class="p">,</span><span class="n">umat_lib</span><span class="p">,</span><span class="n">umat_id</span><span class="p">)</span>
    <span class="n">mat</span><span class="o">.</span><span class="n">props</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">set_material_1_properties</span><span class="p">(</span><span class="mf">2000.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">100.</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">mats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mats</span>
</pre></div>
</div>
<p>The ngeo_parameters.py module contains the relative path to the materials libraries, which specify the different materials available to the user.
The variable umat_id=2 needs to be set for the 2D analyses performed here. It specifies the mapping of the updated vector components of the strain increment <span class="math notranslate nohighlight">\((\gamma_{11},\gamma_{22},\gamma_{12})\)</span></p>
<blockquote>
<div>and corresponding tensor components of the constitutive matrix, with their position in the 3D strain vector and 3D constitutive matrix provided at the material soubroutine (material algorithm).</div></blockquote>
<p>This mapping returns back the correct components of the stress vector and constitutive matrix to pass into the
residual calculation of the weak form in dolfin (equilibrium iterations). The material properties passed into the material algorithm, are set with the helper method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_material_1_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">EE</span><span class="p">,</span><span class="n">nu</span><span class="p">,</span><span class="n">cc</span><span class="p">,</span><span class="n">H</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets material parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GG</span><span class="o">=</span><span class="n">EE</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">nu</span><span class="p">))</span>
    <span class="n">KK</span><span class="o">=</span><span class="n">EE</span><span class="o">*</span><span class="n">GG</span><span class="o">/</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">GG</span><span class="o">-</span><span class="n">EE</span><span class="p">))</span>
    <span class="n">props</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">KK</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">GG</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">12</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">cc</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">15</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">H</span>
    <span class="n">props</span><span class="p">[</span><span class="mi">19</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
    <span class="n">props</span><span class="o">=</span><span class="n">props</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">props</span>
</pre></div>
</div>
<p>In this example we chose to provide the material young modulus EE, Poisson ratio nu, the material yield strength in simple shear cc and the isotropic hardening parameter during yield equal to H=1.
The parameters passed into the material soubroutine are the 3D isotropic compression modulus KK and the shear modulus GG.
Therefore, a transformation of the elastic constants is needed. The elastic constants (GG, KK) used together with the material hardening parameter, H,
and their position in the material properties (numpy array props), can be found in Table (reference needed) and the material library files that accompany Numerical Geolab.</p>
<div class="line-block">
<div class="line">Once the analysis material(s) have been set we are able to exit the class definition for  Cauchy2DFEproblem(UserFEproblem).</div>
</div>
</div>
<div class="section" id="analysis-excecution">
<h2>1.6. Analysis excecution<a class="headerlink" href="#analysis-excecution" title="Permalink to this headline">¶</a></h2>
<p>Our model is now set and ready to run. In order to perform an analysis for the problem at hand, we can simply type:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_FEformulation</span><span class="o">=</span><span class="n">Cauchy2DFEformulation</span><span class="p">()</span>
<span class="n">my_FEproblem</span><span class="o">=</span><span class="n">Cauchy2DFEproblem</span><span class="p">(</span><span class="n">my_FEformulation</span><span class="p">)</span>
<span class="n">path1</span><span class="o">=</span><span class="s1">&#39;../reference_data&#39;</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;Cauchy_2D_Von_Mises_test_step_0&#39;</span>
<span class="n">saveto</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.xdmf&#39;</span><span class="p">)</span>
<span class="n">converged</span><span class="o">=</span><span class="n">my_FEproblem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">saveto</span><span class="p">,</span><span class="n">summary</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This will use the solve method inside the parent UserFeproblem() class that starts the solution procedure. The analysis results are the saved to an ‘.xdmf’ file to be
postprocessed by a third party application (e.g. Paraview).</p>
</div>
<div class="section" id="control-of-the-solution-procedure">
<h2>1.7. Control of the solution procedure<a class="headerlink" href="#control-of-the-solution-procedure" title="Permalink to this headline">¶</a></h2>
<p>The FEproblem() class of Numerical Geolab allows for gret flexibility in choosing the solver parameters with which an analysis can be performed.
Below a set of parameters can be passed as attributes to the solver for controling the frequency of writing output (my_FEproblem.slv.incmodulo),
the tolerance (my_FEproblem.slv.convergence_tol), the maximum increment size (my_FEproblem.slv.dtmax), the maximum analysis time
(my_FEproblem.slv.tmax) and the maximum number of increments (my_FEproblem.slv.nincmax=1000000).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_FEproblem</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">incmodulo</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">my_FEproblem</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">convergence_tol</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">6</span>
<span class="n">my_FEproblem</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">dtmax</span><span class="o">=</span><span class="mf">0.1</span>
<span class="n">my_FEproblem</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">tmax</span><span class="o">=</span><span class="mf">1.</span>
<span class="n">my_FEproblem</span><span class="o">.</span><span class="n">slv</span><span class="o">.</span><span class="n">nincmax</span><span class="o">=</span><span class="mi">1000000</span>
</pre></div>
</div>
</div>
<div class="section" id="analysis-results">
<h2>1.8. Analysis results<a class="headerlink" href="#analysis-results" title="Permalink to this headline">¶</a></h2>
<p>For this simple example we are able to evaluate analyticaly the shear stress, shear strain and the slope of the post yielding branch during the analysis. More specifically form the properties of the above material parameters we have that
the yield stress at pure shear is given by cc=100 kPa and the elastic shear modulus is equal to G=1000 kPa. This specifies the shear displacement value during yield at <span class="math notranslate nohighlight">\(u_y=0.1\)</span> mm. The elastoplastic hardening modulus during yielding of the layer
is then given by the analytical relation, GH= <span class="math notranslate nohighlight">\(GG\frac{cc}{GG+H cc}=\frac{100}{1.1}=90.\overline{90}\)</span>.</p>
<div class="line-block">
<div class="line">Using the folowing python commands we can gain access to the analysis history results for the specific boundary regions specified earlier in</div>
</div>
<dl class="method">
<dt id="history_output">
<code class="descname">history_output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#history_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="line-block">
<div class="line">The results of the history_output() are given as a nested list of the following structure:</div>
</div>
<div class="line-block">
<div class="line">[[0, [force at y in first node of region 2, force at y in second node of region 2 ], [displacement at y in first node of region 2, displacement at y in second node of region 2 ]],…,</div>
<div class="line">[maximum analysis time, [force at y in first node of region 2, force at y in second node of region 2 ], [displacement at y in first node of region 2, displacement at y in second node of region 2 ]]</div>
</div>
<div class="line-block">
<div class="line">In order to extract the results we define a function that unpacks the above nested list into timestamps, nodal displacements and nodel forces</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="k">def</span> <span class="nf">list_unpack</span><span class="p">(</span><span class="n">list1</span><span class="p">):</span>
    <span class="n">list_time</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
    <span class="n">list_force</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">list_disp</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])]</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
        <span class="n">list_time</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">list_force</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">list_disp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">list_time</span><span class="p">,</span> <span class="n">list_force</span><span class="p">,</span> <span class="n">list_disp</span>


<span class="n">analysis_history</span><span class="o">=</span><span class="n">my_FEproblem</span><span class="o">.</span><span class="n">feobj</span><span class="o">.</span><span class="n">problem_history</span>
<span class="n">analysis_history_flat</span><span class="o">=</span><span class="p">[</span><span class="n">elem1</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">analysis_history</span> <span class="k">for</span> <span class="n">elem1</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
<span class="n">list_time</span><span class="p">,</span> <span class="n">list_force</span><span class="p">,</span> <span class="n">list_disp</span> <span class="o">=</span> <span class="n">list_unpack</span><span class="p">(</span><span class="n">analysis_history_flat</span><span class="p">)</span>
<span class="n">array_time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">array_force</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_force</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">0.2</span>
<span class="n">array_disp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_disp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>To obtain the total shear stress on the free end of the layer we add together the nodal forces and divide by the length of the free side, w=0.2. We can then plot the diagram of stress vs displacement
at the free end of the layer. Since a homogeneous deformation problem was studied, this diagram is indicative of the shear sress, shear strain behavior inside the layer.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plotting_params</span><span class="o">.</span><span class="n">object_plot_axes</span><span class="p">(</span><span class="s1">&#39;$u$ [mm]&#39;</span><span class="p">,</span> <span class="s1">&#39;$\sigma$ [kPa]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">plotting_params</span><span class="o">.</span><span class="n">object_plot</span><span class="p">(</span><span class="n">array_disp</span><span class="p">,</span> <span class="o">-</span><span class="n">array_force</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">plotting_params</span><span class="o">.</span><span class="n">plot_legends</span><span class="p">(</span><span class="s1">&#39;./reference_data/&#39;</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span><span class="n">legend_title</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;Cauchy_2D_elastoplastic&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="first last figure align-center" id="id2">
<a class="reference internal image-reference" href="../../_images/Cauchy_2D_elastoplastic1.svg"><img alt="alternate text" height="200px" src="../../_images/Cauchy_2D_elastoplastic1.svg" width="400px" /></a>
<p class="caption"><span class="caption-text">Shear stress displacement diagram at the free end of the layer.</span></p>
</div>
</td>
<td><div class="first last figure align-center" id="id3">
<a class="reference internal image-reference" href="../../_images/Cauchy_simple_shear_end_of_analysis.png"><img alt="alternate text" src="../../_images/Cauchy_simple_shear_end_of_analysis.png" style="width: 400px; height: 200px;" /></a>
<p class="caption"><span class="caption-text">2D Cauchy layer under uniform shear (image produced with the help of third party software Paraview).</span></p>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Numerical Geolab</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Ioannis Stefanou.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="../../_sources/docs/source/Tutorial_Cauchy_elastoplasticity_VM.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>